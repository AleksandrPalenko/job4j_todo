2022-05-19 20:31:46 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Таблица "DATABASECHANGELOGLOCK" не найдена
Table "DATABASECHANGELOGLOCK" not found; SQL statement:
SELECT COUNT(*) FROM DATABASECHANGELOGLOCK [42102-200]
2022-05-19 20:31:47 jdbc[3]: exception
org.h2.jdbc.JdbcSQLDataException: Невозможно преобразование строки "01-04-2021" в тип "TIMESTAMP"
Cannot parse "TIMESTAMP" constant "01-04-2021"; SQL statement:


INSERT INTO items(name, description, created, done) values('Core', 'Task1', '01-04-2021', true); [22007-200]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:457)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:429)
	at org.h2.message.DbException.get(DbException.java:194)
	at org.h2.value.ValueTimestamp.parse(ValueTimestamp.java:136)
	at org.h2.value.Value.convertToTimestamp(Value.java:1169)
	at org.h2.value.Value.convertTo(Value.java:822)
	at org.h2.value.Value.convertTo(Value.java:772)
	at org.h2.value.TypeInfo.cast(TypeInfo.java:515)
	at org.h2.table.Column.validateConvertUpdateSequence(Column.java:378)
	at org.h2.table.Table.validateConvertUpdateSequence(Table.java:845)
	at org.h2.command.dml.Insert.insertRows(Insert.java:187)
	at org.h2.command.dml.Insert.update(Insert.java:151)
	at org.h2.command.CommandContainer.update(CommandContainer.java:198)
	at org.h2.command.Command.executeUpdate(Command.java:251)
	at org.h2.command.CommandList.update(CommandList.java:66)
	at org.h2.command.CommandList.executeRemaining(CommandList.java:59)
	at org.h2.command.CommandList.update(CommandList.java:67)
	at org.h2.command.Command.executeUpdate(Command.java:251)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:228)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:201)
	at liquibase.executor.jvm.JdbcExecutor$ExecuteStatementCallback.doInStatement(JdbcExecutor.java:352)
	at liquibase.executor.jvm.JdbcExecutor.execute(JdbcExecutor.java:57)
	at liquibase.executor.jvm.JdbcExecutor.execute(JdbcExecutor.java:125)
	at liquibase.database.AbstractJdbcDatabase.execute(AbstractJdbcDatabase.java:1229)
	at liquibase.database.AbstractJdbcDatabase.executeStatements(AbstractJdbcDatabase.java:1211)
	at liquibase.changelog.ChangeSet.execute(ChangeSet.java:600)
	at liquibase.changelog.visitor.UpdateVisitor.visit(UpdateVisitor.java:53)
	at liquibase.changelog.ChangeLogIterator.run(ChangeLogIterator.java:78)
	at liquibase.Liquibase.update(Liquibase.java:202)
	at liquibase.Liquibase.update(Liquibase.java:179)
	at liquibase.Liquibase.update(Liquibase.java:334)
	at org.liquibase.maven.plugins.LiquibaseUpdate.doUpdate(LiquibaseUpdate.java:33)
	at org.liquibase.maven.plugins.AbstractLiquibaseUpdateMojo.performLiquibaseTask(AbstractLiquibaseUpdateMojo.java:30)
	at org.liquibase.maven.plugins.AbstractLiquibaseMojo.execute(AbstractLiquibaseMojo.java:366)
	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:137)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:210)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:156)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:148)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81)
	at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:56)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:305)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:192)
	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:105)
	at org.apache.maven.cli.MavenCli.execute(MavenCli.java:957)
	at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:289)
	at org.apache.maven.cli.MavenCli.main(MavenCli.java:193)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:282)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:225)
	at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:406)
	at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:347)
	at org.codehaus.classworlds.Launcher.main(Launcher.java:47)
Caused by: java.lang.IllegalArgumentException: 1-4-2021
	at org.h2.util.DateTimeUtils.parseDateValue(DateTimeUtils.java:173)
	at org.h2.util.DateTimeUtils.parseTimestamp(DateTimeUtils.java:316)
	at org.h2.value.ValueTimestamp.parse(ValueTimestamp.java:134)
	... 53 more
2022-05-19 20:32:30 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Таблица "ITEMS" уже существует
Table "ITEMS" already exists; SQL statement:
CREATE TABLE items (
	id SERIAL PRIMARY KEY,
	name text,
	description text,
	created timestamp default current_timestamp,
	done BOOLEAN default false
); [42101-200]
2022-05-19 21:04:20 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Таблица "ITEMS" уже существует
Table "ITEMS" already exists; SQL statement:
CREATE TABLE items (
	id SERIAL PRIMARY KEY,
	name text,
	description text,
	created timestamp default current_timestamp,
	done BOOLEAN default false
); [42101-200]
2022-05-19 21:05:18 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Таблица "ITEMS" уже существует
Table "ITEMS" already exists; SQL statement:
CREATE TABLE items (
	id SERIAL PRIMARY KEY,
	name text,
	description text,
	created timestamp default current_timestamp,
	done BOOLEAN default false
); [42101-200]
2022-05-19 21:05:41 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "CREATE TABLE IS[*] NOT EXISTS ITEMS (
	ID SERIAL PRIMARY KEY,
	NAME TEXT,
	DESCRIPTION TEXT,
	CREATED TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	DONE BOOLEAN DEFAULT FALSE
);

INSERT INTO ITEMS(NAME, DESCRIPTION, CREATED, DONE) VALUES('Core', 'Task1', '01-04-2021', TRUE);
INSERT INTO ITEMS(NAME, DESCRIPTION, CREATED, DONE) VALUES('SPRING', 'Task2', '01-04-2022', FALSE);
INSERT INTO ITEMS(NAME, DESCRIPTION, CREATED, DONE) VALUES('Hibernate', 'Task3', '01-05-2022', FALSE);"; ожидалось "identifier"
Syntax error in SQL statement "CREATE TABLE IS[*] NOT EXISTS ITEMS (
	ID SERIAL PRIMARY KEY,
	NAME TEXT,
	DESCRIPTION TEXT,
	CREATED TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	DONE BOOLEAN DEFAULT FALSE
);

INSERT INTO ITEMS(NAME, DESCRIPTION, CREATED, DONE) VALUES('Core', 'Task1', '01-04-2021', TRUE);
INSERT INTO ITEMS(NAME, DESCRIPTION, CREATED, DONE) VALUES('SPRING', 'Task2', '01-04-2022', FALSE);
INSERT INTO ITEMS(NAME, DESCRIPTION, CREATED, DONE) VALUES('Hibernate', 'Task3', '01-05-2022', FALSE);"; expected "identifier"; SQL statement:
CREATE TABLE is not exists items (
	id SERIAL PRIMARY KEY,
	name text,
	description text,
	created timestamp default current_timestamp,
	done BOOLEAN default false
);

INSERT INTO items(name, description, created, done) values('Core', 'Task1', '01-04-2021', true);
INSERT INTO items(name, description, created, done) values('SPRING', 'Task2', '01-04-2022', false);
INSERT INTO items(name, description, created, done) values('Hibernate', 'Task3', '01-05-2022', false); [42001-200]
2022-05-19 21:06:12 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "CREATE IS[*] NOT EXISTS TABLE ITEMS (
	ID SERIAL PRIMARY KEY,
	NAME TEXT,
	DESCRIPTION TEXT,
	CREATED TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	DONE BOOLEAN DEFAULT FALSE
);

INSERT INTO ITEMS(NAME, DESCRIPTION, CREATED, DONE) VALUES('Core', 'Task1', '01-04-2021', TRUE);
INSERT INTO ITEMS(NAME, DESCRIPTION, CREATED, DONE) VALUES('SPRING', 'Task2', '01-04-2022', FALSE);
INSERT INTO ITEMS(NAME, DESCRIPTION, CREATED, DONE) VALUES('Hibernate', 'Task3', '01-05-2022', FALSE);"; ожидалось "OR, FORCE, VIEW, ALIAS, SEQUENCE, USER, TRIGGER, ROLE, SCHEMA, CONSTANT, DOMAIN, TYPE, DATATYPE, AGGREGATE, LINKED, MEMORY, CACHED, LOCAL, GLOBAL, TEMP, TEMPORARY, TABLE, SYNONYM, PRIMARY, UNIQUE, HASH, SPATIAL, INDEX"
Syntax error in SQL statement "CREATE IS[*] NOT EXISTS TABLE ITEMS (
	ID SERIAL PRIMARY KEY,
	NAME TEXT,
	DESCRIPTION TEXT,
	CREATED TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	DONE BOOLEAN DEFAULT FALSE
);

INSERT INTO ITEMS(NAME, DESCRIPTION, CREATED, DONE) VALUES('Core', 'Task1', '01-04-2021', TRUE);
INSERT INTO ITEMS(NAME, DESCRIPTION, CREATED, DONE) VALUES('SPRING', 'Task2', '01-04-2022', FALSE);
INSERT INTO ITEMS(NAME, DESCRIPTION, CREATED, DONE) VALUES('Hibernate', 'Task3', '01-05-2022', FALSE);"; expected "OR, FORCE, VIEW, ALIAS, SEQUENCE, USER, TRIGGER, ROLE, SCHEMA, CONSTANT, DOMAIN, TYPE, DATATYPE, AGGREGATE, LINKED, MEMORY, CACHED, LOCAL, GLOBAL, TEMP, TEMPORARY, TABLE, SYNONYM, PRIMARY, UNIQUE, HASH, SPATIAL, INDEX"; SQL statement:
CREATE is not exists TABLE items (
	id SERIAL PRIMARY KEY,
	name text,
	description text,
	created timestamp default current_timestamp,
	done BOOLEAN default false
);

INSERT INTO items(name, description, created, done) values('Core', 'Task1', '01-04-2021', true);
INSERT INTO items(name, description, created, done) values('SPRING', 'Task2', '01-04-2022', false);
INSERT INTO items(name, description, created, done) values('Hibernate', 'Task3', '01-05-2022', false); [42001-200]
2022-05-19 21:06:36 jdbc[3]: exception
org.h2.jdbc.JdbcSQLDataException: Невозможно преобразование строки "01-04-2021" в тип "TIMESTAMP"
Cannot parse "TIMESTAMP" constant "01-04-2021"; SQL statement:
CREATE TABLE if not exists items (
	id SERIAL PRIMARY KEY,
	name text,
	description text,
	created timestamp default current_timestamp,
	done BOOLEAN default false
); [22007-200]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:457)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:429)
	at org.h2.message.DbException.get(DbException.java:194)
	at org.h2.value.ValueTimestamp.parse(ValueTimestamp.java:136)
	at org.h2.value.Value.convertToTimestamp(Value.java:1169)
	at org.h2.value.Value.convertTo(Value.java:822)
	at org.h2.value.Value.convertTo(Value.java:772)
	at org.h2.value.TypeInfo.cast(TypeInfo.java:515)
	at org.h2.table.Column.validateConvertUpdateSequence(Column.java:378)
	at org.h2.table.Table.validateConvertUpdateSequence(Table.java:845)
	at org.h2.command.dml.Insert.insertRows(Insert.java:187)
	at org.h2.command.dml.Insert.update(Insert.java:151)
	at org.h2.command.CommandList.executeRemaining(CommandList.java:50)
	at org.h2.command.CommandList.update(CommandList.java:67)
	at org.h2.command.Command.executeUpdate(Command.java:251)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:228)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:201)
	at liquibase.executor.jvm.JdbcExecutor$ExecuteStatementCallback.doInStatement(JdbcExecutor.java:352)
	at liquibase.executor.jvm.JdbcExecutor.execute(JdbcExecutor.java:57)
	at liquibase.executor.jvm.JdbcExecutor.execute(JdbcExecutor.java:125)
	at liquibase.database.AbstractJdbcDatabase.execute(AbstractJdbcDatabase.java:1229)
	at liquibase.database.AbstractJdbcDatabase.executeStatements(AbstractJdbcDatabase.java:1211)
	at liquibase.changelog.ChangeSet.execute(ChangeSet.java:600)
	at liquibase.changelog.visitor.UpdateVisitor.visit(UpdateVisitor.java:53)
	at liquibase.changelog.ChangeLogIterator.run(ChangeLogIterator.java:78)
	at liquibase.Liquibase.update(Liquibase.java:202)
	at liquibase.Liquibase.update(Liquibase.java:179)
	at liquibase.Liquibase.update(Liquibase.java:334)
	at org.liquibase.maven.plugins.LiquibaseUpdate.doUpdate(LiquibaseUpdate.java:33)
	at org.liquibase.maven.plugins.AbstractLiquibaseUpdateMojo.performLiquibaseTask(AbstractLiquibaseUpdateMojo.java:30)
	at org.liquibase.maven.plugins.AbstractLiquibaseMojo.execute(AbstractLiquibaseMojo.java:366)
	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:137)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:210)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:156)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:148)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81)
	at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:56)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:305)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:192)
	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:105)
	at org.apache.maven.cli.MavenCli.execute(MavenCli.java:957)
	at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:289)
	at org.apache.maven.cli.MavenCli.main(MavenCli.java:193)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:282)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:225)
	at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:406)
	at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:347)
	at org.codehaus.classworlds.Launcher.main(Launcher.java:47)
Caused by: java.lang.IllegalArgumentException: 1-4-2021
	at org.h2.util.DateTimeUtils.parseDateValue(DateTimeUtils.java:173)
	at org.h2.util.DateTimeUtils.parseTimestamp(DateTimeUtils.java:316)
	at org.h2.value.ValueTimestamp.parse(ValueTimestamp.java:134)
	... 50 more
